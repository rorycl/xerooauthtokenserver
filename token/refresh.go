package token

import (
	"log"
	"time"
)

// updater is a function that returns a channel to refresh a token if it
// is due to expire
func (t *Token) refresher() <-chan struct{} {
	ticker := time.NewTicker(t.expireTimeTicker)
	refresher := make(chan struct{})
	go func() {
		for {
			select {
			case <-ticker.C:
				if t.expiring() {
					refresher <- struct{}{}
				}
			}
		}
	}()
	return refresher
}

// expiring determines if the RefreshToken is about to expire; return
// early if the system has not been initialised
func (t *Token) expiring() bool {
	if t.AccessToken == "" || t.RefreshToken == "" {
		return false
	}
	now := time.Now().UTC()
	expiration := t.RefreshTokenExpiryUTC.Add(-t.expirySecs)
	if now.After(expiration) {
		return true
	}
	return false
}

// refreshRunner triggers a token refresh generated by communication on
// the refresher channel; this is separated from the refresher function
// to allow for testing
func (t *Token) refreshRunner(refresher <-chan struct{}) {
	go func() {
		for range refresher {
			err := t.Refresh()
			log.Println("running refresh")
			if err != nil {
				log.Printf("refresh error %s", err)
			}
		}
	}()
}
